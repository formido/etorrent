Haphazard TODO list of things that needs attention:

* DONE Warn if we get old ACKs, there seem to be no control of this.
   We better have a check for this, otherwise we can simply add a
   large number of dumb errors to the code base later on.
* DONE We don't update the advertized window at all.
   We should begin planning how to handle the advertised window. We
   are currently killing the receiver because we are sending too fast
   and he has begun dropping packets.

   To make the window going:
   DONE ; Whenever we send out a packet, calculate the current window and
     stamp it into the packet
   DONE ; Figure out how to set the advertised window on outgoing packets.
   DONE ; Set window on outgoing advertised packets.

   DONE ; Figure out how to do this.
     It requires us to make a calculation based on the advertised
     window from the other end. When this is properly updated, we must
     calculate how many packets there are currently fitting into the
     window, and only send this amount to the other end.

   DONE ; When the connection is establishes, we will get an advertized
     window from the other end which we must obey. We don't currently.
   DONE ; When we receive a packet, be sure to make the correct window
     updates
   DONE ; When the packet fill code runs, we are currently shoving empty
     packets into the stream. This ought to be fixed - quickly.

   DONE ; Check that the window gets advertised correctly towards the other
     end.
   DONE ; Only send packets up to the window size.
  
   DONE ; Handle the special case of a zero packet window. It is a quite
     important special-case because you should only open up the window
     again, if a full packet can be injected in-flight. Otherwise, you
     must let the other end keep processing stuff.

   DONE ; Should ST_STATE packets bump the seq_no?

* DONE Figure out why our test fails
  The 2nd of our tests fail for some reason, but we need to know why
  exactly.

  Out test fails due to retransmissions it seems. We can thus try to
  implement retransmissions and see if this solves the problem!
* Retransmissions
  How should we handle retransmission of missing packets? This is
  needed before we can go to a check over the internet.
** DONE Propagate information if the ACK is moving ahead!
** DONE Set up a retransmission timer with a fairly large window of 3 seconds.
*** DONE Detect the need for retransmissions
    What are exactly the need for retransmissions?

    You should detect the case where there are no more bytes in-flight
    to send out. In that case, you should mark a message down with
    this information.
*** DONE Mark in the ACK-code when the in-flight buffer is empty
*** DONE Set up a retransmission timer and build a correct cancellation of it as well
*** DONE Handle the all_acked case in the retransmission timer as well.
    We are currently not handling this case correctly and we should.
** DONE Install the retransmissions code.
   Increase the timeout by two every time the retransmission timer ticks.
** DONE Write code for retransmitting the oldest frame
   With this, we gamble we only lost a single frame in the stream,
   though this is probably not going to be true in the general case
* DONE There is a bug when creating multiple connections, fix
  The second created connection seem to stall, and I wonder why. This
  should be investigated as the fix is needed to make the code work
  anyway!

  This error is interesting:

  ** exception error: no match of right hand side value 
                    {error,{already_started,<0.60.0>}}
     in function  gen_utp:connect/3
     in call from utp:test_connector_1/0
* TODO The ACK in the connectee@ is seen as old, investigate
  There is something along the lines of the numbering that doesn't
  work here. It ought to be fixed. But we place it down here to
  concentrate on other stuff first.

  The problem is that we find an ACK and that ACK is older than what
  we expect it to be. This is wrong, and we should fix it. We should
  get an ACK which is equivalent to the last acked packet. I.e., it
  should be equivalent to a window probe request. It is off-by-one and
  sometimes it is off by two (??).
* DONE ZeroWindow Timeouts
** DONE Move the Zerowindow check out of handle-packet. It has no place in there
** DONE Install and remove the zerowindow timeout
   When the window closes to 0, we should start the zerowindow
   timer. If nothing has happened for some time, we will then send out
   a window probe to coax the other end into sending back an ACK with
   an updated window.
*** DONE Installation
   When the window closes to 0, we should install the timer.
*** DONE UnInstallation
   If there is already a timer installed, remove it when the window
   opens above 0.
** DONE Figure out the exact construction of the window probe packet
   We don't know exactly what the probe packet looks like. We better
   read the source code of libutp to see what it looks like.

   There is no window probe packet. One simply bumps the window size
   >.< ... that is a majorly bad idea, but what the protocol does.
*** DONE Timer triggering
   If this timer triggers, it means we should send forth a
   window-probe packet. This is a packet which will trigger an ACK the
   other way.

   No, it means: Increase the window by one and then try to fill up
   the buffer if possible again!
* TODO Force an st_state packet through when the window *reopens*
  If we have a window that is down to 0, and we then suddenly get a
  receiver on the socket reading data out of it such that we detect
  the window open up again, we should always send a window update
  packet in this case.
* TODO Consider moving the window-specific code to its own module.
* TODO Re-read the uTP BEP 29 spec again
* DONE SYN Timeouts should just be part of retransmit timeouts?
  Yep, they should.
** DONE Read the libutp source and figure out the normal retransmit time for SYNs
   The normal retransmit time is two tries: one at 3 secs, one at 6
   secs and then at 12, we give up. OK. That should be easy to implement.
** DONE Set up the retransmit timer in uTP to match this.
** DONE Keep trying and fail if it takes too long upon timer triggers.
** DONE Ignore the special cases a bit for now.
* DONE Socket Close
  How to implement socket closedown?

  Basic socket closedown is done. We have pushed the problem to other
  states now!
** DONE Make a plan and understand what is going on!
   It is based on the idea of FIN packets. Does it allow half-open
   connections?

   The plan is to figure out some general things, and then attack each
   possible state transition one by one. It begs some general
   questions, which we can probably answer by digging into the code.
** DONE Does uTP allow for half-open connections?
   Investigate the source code of libutp to figure this out!

   No! uTP has no concept of half-open connections!
** DONE How is the two-army problem handled?
   By timeouts, we know that.
** DONE Individual states:
   A transition happens on a given state with a given input.

   For each of these state transitions, understand specifically what
   happens in the transition and make a plan for it.

   Handle them by implementing what we think is the bare minimum and
   then build on from there!
** DONE 1: CONNECTED + close()
*** DONE Check the source of libutp
*** DONE We should send off a st_fin packet
*** DONE The st_fin packet should be entered in the retransmission buffer!
*** DONE We should transition to fin_sent in state.
** DONE 2: CONNECTED + pkt(st_fin)
    Mark where the end of the stream is
**** DONE What does libutp do?
     What happens when the incoming packet is of type st_fin?

     What happens to all who are awaiting transfer of data when the
     buffer closes.
**** DONE When the buffer closes, we should stop satisfying data to the upper layer
     According to spec, this is what should happen. So if we close the
     line in the send direction, we are also closing the line in the
     receive direction. In other words, we don't use the concept of
     half-open connections.
**** DONE When receiving a FIN packet, install a knowledge of this in the pkt_buffer
     We should record that we got a fin packet, and what seq_no is
     stamped with the fin.
**** DONE Set a Message which says we got the fin packet.
**** DONE Make sure we don't send data to the upper layer when a fin has been sent!
**** DONE Should the ST_FIN packet go to the retransmit buffer?
     Yes, make it so!

     It is written like any other packet, eventually of size 0 but is
     present in the reorder buffer so it will be transmitted safely
     eventually. It is not simply an ACK for state updates.
** DONE Implement the FIN_SENT state properly
*** DONE Refactor out pkt receives from the other end from connected
    We need this code present in the fin_sent state as well, so factor
    it out such that we can use it here as well.
*** DONE Implement the altered state on how to handle the next state in this.
** DONE How do we leave FIN_SENT?
     We leave FIN_SENT as soon as we either timeout, or if we get acks
     back up to the FIN_PACKET. In this case, we move to the DESTROY
     state.
*** DONE Detect that the ST_FIN packet was acked by the last ACK
** DONE Figure out exactly what happens when an ST_FIN packet is received
     There are two points in time. When we get the packet in, and when
     we ACK it because we reach it in the reorder buffer. Which should
     force the state change to the GOT_FIN state? Look in the libutp
     code.

     When we *CONFIRM* the eof_pkt by ACK'ing in our end, we move the
     the GOT_FIN state.

     When we *SEE* the packet, we track that we have seen a finalizer
     packet, but we don't do any state updates and stay in the
     CONNECTED state in this case.
** DONE When we confirm the eof_pkt from the reorder buffer, we should post a message this is the case
     The reason we should post this to the worker process is such that
     it can alter the state to a new one. Otherwise we will entangle
     different parts to each other.
** DONE When we confirm the FIN packet, our new state is GOT_FIN *unless* FIN_SENT is our current one
     This is because in the FIN_SENT state we are just about to close
     down anyway, so there is no reason to move to GOT_FIN.
** DONE If we are in FIN_SENT and we *Confirm* an ACK, move to FIN_SENT
   Done. This is automatically fixed in our code since the path is
   split correctly. We don't need to handle this case at all!
** DONE In States which are not CONNECTED, nor FIN_SENT we can't accept new data.
*** DONE If we know the eof_pkt and receive packets past it, throw them out!
     We can simply enter them in the reorder buffer and soundly ignore them.
*** DONE 3: SYN_SENT + close()
    Set timeout to the minimum of 60 and the conn rto * 2
*** DONE 4: GOT_FIN + close()
    Move to DESTROY_DELAY
*** DONE 5: ALL_OTHER_STATES + close()
    Move to DESTROY!
*** TODO DESTROY
    Destroy should clean up stuff. What stuff should it clean up, and
    how?

    We should report back to clients waiting on the socket for data
    that this won't happen.
* DONE FIN_SENT and timeout
** DONE What should be done here?
   I am pretty sure we should be moving to another state, but I am not
   which state we should move to. Investigate the libutp C++ code.

   Easy: Increase RTO. If new RTO is above threshold (30 secs) then
   move to DESTROY as a state.
* DONE GOT_FIN and timeout
** DONE What should be done here?
   This is yet another of those questions we want to answer. How do we
   get *away* from the GOT_FIN state?

   We should move to the state CS_RESET
* DONE DESTROY_DELAY and timeout()
  Move to CS_DESTROY!
* DONE FIN_SENT and send()
* DONE FIN_SENT and recv()
* DONE 3: GOT_FIN how do we react on a GOT_FIN?
*** DONE GOT_FIN || DESTROY_DELAY + timeout() ?
     The rule here is that we should go to DESTROY (for DESTROY_DELAY)
     And we should go to RESET (for GOT_FIN).
     We must tell callers that we have an ECONNRESET as well.
*** DONE GOT_FIN + recv() --> error, can't*
    ECONNRESET?
*** DONE GOT_FIN + send() --> error, can't
* DONE CS_RESET state
  This is another question-mark. What should we do in the CS_RESET
  state? We Better read the source of libutp.

  Hmm, there is nothing to do in this state. Essentially, we should
  just move to the DESTROY state right away. It is rather odd that
  this state exists. It may have been an old fluke from the early days
  of the protocol. I am willing to just destroy the line instead.
** DONE Use the RESET state to confirm a close.
   In this state, we just deny everyone everything until we get a
   close() on the socket at which point we move to the DESTROY state.
* DONE DESTROY how do we react on a DESTROY?
    Set a timeout
    When the timeout trigger, we remove everything on this socket by
    closing down. We do however tell back to parents waiting that the
    socket is going to be destroyed.

    That is essentially all!
** DONE Write code which can walk through the senders and receivers and send them messages
   This means we can send out messages to all clients who are waiting
   on us to do something. We can call this either from the DESTROY
   state as a safeguard, or we can call it earlier if some states
   requires us to exit out earlier with other kinds of information. It
   also allows us to handle the ETIMEDOUT error correctly, I guess.
* DONE RESET packets
  We currently have no handling of RESET packets at all. It ought to
  be pretty simple though and can be added easily I think.
** DONE ST_RESET Packet in the receive direction
   We receive an ST_RESET packet for a connection. This means we
   should stop processing and die. The rule is that in a FIN_SENT
   state we should move to DESTROY. In other states we should move to
   RESET. The error message to return up is based on whether or not we
   are in SYN_SENT. In SYN_SENT, it is ECONNREFUSED. Otherwise it is
   ECONNRESET!
*** DONE Add the ability to handle a reset() call for a given socket.
    In this state, we should carry out the things we have written down
    above.
** DONE ST_RESET Packet in the send direction
   This happens on a failed lookup. There is no such socket present,
   so when we try to look up the socket, we fail. This means we send
   off an RST packet, but store a "Do not send off another RST Packet
   for this unless a grace time has happened" entry in the lookup
   table.
*** DONE Write code for the transmission of a RESET packet
*** DONE Install on a failed lookup
* DONE Assert all messaging goes through OK
  This is really a bit hacky, but I'd rather assert that all the UDP
  packets are released correctly to the underlying operating system
  for now. If not, we ought to handle it explicitly anyway.
* ONGOING Test the retransmission code
** DONE Make DUMMYNET work on FreeBSD
** DONE Test the code on FreeBSD again!
** DONE Create a script with a low-level error rate.
** DONE TEST with a low-level error rate.
** DONE Create a script with a medium level error rate.
** Create a script that totally fucks up the connection ordering.
** Create a script which does everything in a nasty way.
** Create a script which is close to realistic.
** TODO Fix the zerowindow bug
   There are probably a couple of bugs. One is that we should remember
   to reopen the zero window.
* TODO Fix the "ACK-is-old" bug.
  When we get in packets, the ACK is classified as an old ACK. This is
  an error somewhere in the code and should be fixed.

  The ACK is old because we send back an ACK which is too low in value
  compared to what the receiver expects.

  1: Is the receiver the connector or the connected?
  2: What code is the code that sends off the ACK?
  3: Where does the ACK stem from? From the initial connect setup
     code?
  4: Why is it off-by-two or off-by-one?
  5: Is this an error w.r.t. that the ACK is the next expected ACK?

* TODO We sometimes hit {error, enobufs}
  On the FreeBSD machine. Investigate and handle this kind of error
  message.
* TODO Robustness falters under heavy packet loss.
  When the packet loss is very heavy, the robustness of the system is
  worse than it normally is. We ought to investigate why this is the
  case and fix it.
* TODO Retransmission of the syn packet seems to fail for some reason.
  Investigate why this is the case and fix it.
* TODO Only install the zerowin timer if there are more data to send out
  We are currently always setting the ZeroWindow timer when the
  peer_advertised_window is 0, but we could postpone that decision
  until we know we need to send data to the other end.
* The ConnId lookup table should guard against generating an already existing random number.
* Grace period on used ConnIDs?
  When we have used a ConnID for a while, should we accept another one
  straight after? It sounds like a bad idea because it may time out
  for some reason. 

  On the other hand the conn_id/ip pair makes sure we are not
  expecting data from this guy in any other way. Someone with another
  ID would not be able to send to the socket unless he had the same IP
  address then. It makes the collisions much less likely to occur in
  the implementation to use this. In fact, it is 1/2**32. Rather good,
  and not at all realistic for a match.
* ACK piggybacking
* Delayed ACKS
** TODO Make sure we immediately ack the FIN packet. Don't delay him!
     Easy right now, but keep this as it is important when you
     introduce delayed ACKs











* RTT Measurement
  This is probably different in uTP from the standard protocol
* SACK support
* Nagle code
* TODO Add a safety timer on RESET Packets
* TODO There are some states that can't cope with a RESET yet
  But it doesn't matter at the moment. I'd rather look into other
  errors first and get those away first. Then we can look into this
  which should be fairly automated to add later on.




